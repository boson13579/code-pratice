# DP[i][j] 表示 s1 前 i 個和 s2 前 j 個的最大得分

//init
DP[0][0] = 0
for i in 1 to len(s1): DP[i][0] = DP[i-1][0] + M[s1[i-1]][' ']
for i in 1 to len(s2): DP[i][0] = DP[i-1][0] + M[s2[i-1]][' ']

for i in 1 to len(s1):
    for j in 1 to len(s2):
        DP[i][j] = max(DP[i][j], DP[i-1][j-1] + M[s1[i-1]][s2[j-1]]) //match
        DP[i][j] = max(DP[i][j], DP[i-1][j] + M[s1[i-1]][' '])       //add space on s2[j]
        DP[i][j] = max(DP[i][j], DP[i][j-1] + M[' '][s2[j-1]])       //add space on s1[i]

return DP[len(s1)][len(s2)]

# Time complexity : O(mn)
# Space complexity : O(mn)
# m = len(s1), n = len(s2)

traceback(i, j):
    if i ==0 and j==0: return 
    if DP[i][j] == DP[i-1][j-1] + M[s1[i-1]][s2[j-1]]: return traceback(i-1, j-1)
    if DP[i][j] == DP[i-1][j] + M[s1[i-1]][' ']:
        print("在S2的第",j,"項添加space")
        return traceback(i-1, j)
    if DP[i][j] =  DP[i][j-1] + M[' '][s2[j-1]]:
        print("在S1的第",i,"項添加space")
        return traceback(i, j-1)

# Time complexity : O(m+n) all is space
# Space complexity : O(mn) 剛剛DP的表格

